
naputin.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009c  00800100  00000b32  00000bc6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b32  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000f  0080019c  0080019c  00000c62  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  00000c62  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000180  00000000  00000000  00000d22  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000d0b  00000000  00000000  00000ea2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000040b  00000000  00000000  00001bad  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000c83  00000000  00000000  00001fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000120  00000000  00000000  00002c3c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000041f  00000000  00000000  00002d5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000082a  00000000  00000000  0000317b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000f0  00000000  00000000  000039a5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
}


// perform a single keystroke
int8_t usb_keyboard_press(uint8_t key, uint8_t modifier)
{
   0:	f0 c0       	rjmp	.+480    	; 0x1e2 <__ctors_end>

void phex16(unsigned int i)
{
	phex(i >> 8);
	phex(i);
}
   2:	00 00       	nop
   4:	09 c1       	rjmp	.+530    	; 0x218 <__bad_interrupt>
   6:	00 00       	nop
   8:	07 c1       	rjmp	.+526    	; 0x218 <__bad_interrupt>
   a:	00 00       	nop
   c:	05 c1       	rjmp	.+522    	; 0x218 <__bad_interrupt>
   e:	00 00       	nop
  10:	03 c1       	rjmp	.+518    	; 0x218 <__bad_interrupt>
  12:	00 00       	nop
  14:	01 c1       	rjmp	.+514    	; 0x218 <__bad_interrupt>
  16:	00 00       	nop
  18:	ff c0       	rjmp	.+510    	; 0x218 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	fd c0       	rjmp	.+506    	; 0x218 <__bad_interrupt>
  1e:	00 00       	nop
  20:	fb c0       	rjmp	.+502    	; 0x218 <__bad_interrupt>
  22:	00 00       	nop
  24:	f9 c0       	rjmp	.+498    	; 0x218 <__bad_interrupt>
  26:	00 00       	nop
  28:	37 c3       	rjmp	.+1646   	; 0x698 <__vector_10>
  2a:	00 00       	nop
  2c:	b7 c3       	rjmp	.+1902   	; 0x79c <__vector_11>
  2e:	00 00       	nop
  30:	f3 c0       	rjmp	.+486    	; 0x218 <__bad_interrupt>
  32:	00 00       	nop
  34:	f1 c0       	rjmp	.+482    	; 0x218 <__bad_interrupt>
  36:	00 00       	nop
  38:	ef c0       	rjmp	.+478    	; 0x218 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	ed c0       	rjmp	.+474    	; 0x218 <__bad_interrupt>
  3e:	00 00       	nop
  40:	eb c0       	rjmp	.+470    	; 0x218 <__bad_interrupt>
  42:	00 00       	nop
  44:	e9 c0       	rjmp	.+466    	; 0x218 <__bad_interrupt>
  46:	00 00       	nop
  48:	e7 c0       	rjmp	.+462    	; 0x218 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	e5 c0       	rjmp	.+458    	; 0x218 <__bad_interrupt>
  4e:	00 00       	nop
  50:	e3 c0       	rjmp	.+454    	; 0x218 <__bad_interrupt>
  52:	00 00       	nop
  54:	e1 c0       	rjmp	.+450    	; 0x218 <__bad_interrupt>
  56:	00 00       	nop
  58:	df c0       	rjmp	.+446    	; 0x218 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	15 c1       	rjmp	.+554    	; 0x288 <__vector_23>
  5e:	00 00       	nop
  60:	db c0       	rjmp	.+438    	; 0x218 <__bad_interrupt>
  62:	00 00       	nop
  64:	d9 c0       	rjmp	.+434    	; 0x218 <__bad_interrupt>
  66:	00 00       	nop
  68:	d7 c0       	rjmp	.+430    	; 0x218 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	d5 c0       	rjmp	.+426    	; 0x218 <__bad_interrupt>
  6e:	00 00       	nop
  70:	d3 c0       	rjmp	.+422    	; 0x218 <__bad_interrupt>
  72:	00 00       	nop
  74:	d1 c0       	rjmp	.+418    	; 0x218 <__bad_interrupt>
  76:	00 00       	nop
  78:	cf c0       	rjmp	.+414    	; 0x218 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	cd c0       	rjmp	.+410    	; 0x218 <__bad_interrupt>
  7e:	00 00       	nop
  80:	cb c0       	rjmp	.+406    	; 0x218 <__bad_interrupt>
  82:	00 00       	nop
  84:	c9 c0       	rjmp	.+402    	; 0x218 <__bad_interrupt>
  86:	00 00       	nop
  88:	c7 c0       	rjmp	.+398    	; 0x218 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	c5 c0       	rjmp	.+394    	; 0x218 <__bad_interrupt>
  8e:	00 00       	nop
  90:	c3 c0       	rjmp	.+390    	; 0x218 <__bad_interrupt>
  92:	00 00       	nop
  94:	c1 c0       	rjmp	.+386    	; 0x218 <__bad_interrupt>
  96:	00 00       	nop
  98:	bf c0       	rjmp	.+382    	; 0x218 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	bd c0       	rjmp	.+378    	; 0x218 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	bb c0       	rjmp	.+374    	; 0x218 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	b9 c0       	rjmp	.+370    	; 0x218 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	b7 c0       	rjmp	.+366    	; 0x218 <__bad_interrupt>
  aa:	00 00       	nop

000000ac <__c.1415>:
  ac:	0a 6d 61 69 6e 20 6c 6f 6f 70 20 73 74 61 72 74     .main loop start
  bc:	65 64 0a 00                                         ed..

000000c0 <__c.1413>:
  c0:	75 73 62 20 63 6f 6e 66 69 67 75 72 65 64 0a 00     usb configured..

000000d0 <descriptor_list>:
  d0:	00 01 00 00 17 01 12 00 02 00 00 29 01 3b 00 22     ...........).;."
  e0:	00 00 64 01 3f 00 21 00 00 3b 01 09 00 22 01 00     ..d.?.!..;..."..
  f0:	a3 01 15 00 21 01 00 54 01 09 00 03 00 00 b8 01     ....!..T........
 100:	04 01 03 09 04 bc 01 10 02 03 09 04 ce 01 12        ...............

0000010f <endpoint_config_table>:
 10f:	00 00 01 c1 06 01 c1 26                             .......&

00000117 <device_descriptor>:
 117:	12 01 00 02 00 00 00 20 c0 16 7d 04 00 01 01 02     ....... ..}.....
 127:	00 01                                               ..

00000129 <config1_descriptor>:
 129:	09 02 3b 00 02 01 00 c0 32 09 04 00 00 01 03 01     ..;.....2.......
 139:	01 00 09 21 11 01 00 01 22 3f 00 07 05 83 03 08     ...!...."?......
 149:	00 01 09 04 01 00 01 03 00 00 00 09 21 11 01 00     ............!...
 159:	01 22 15 00 07 05 84 03 20 00 01                    ."...... ..

00000164 <keyboard_hid_report_desc>:
 164:	05 01 09 06 a1 01 75 01 95 08 05 07 19 e0 29 e7     ......u.......).
 174:	15 00 25 01 81 02 95 01 75 08 81 03 95 05 75 01     ..%.....u.....u.
 184:	05 08 19 01 29 05 91 02 95 01 75 03 91 03 95 06     ....).....u.....
 194:	75 08 15 00 25 68 05 07 19 00 29 68 81 00 c0        u...%h....)h...

000001a3 <debug_hid_report_desc>:
 1a3:	06 31 ff 09 74 a1 53 75 08 15 00 26 ff 00 95 20     .1..t.Su...&... 
 1b3:	09 75 81 02 c0                                      .u...

000001b8 <string0>:
 1b8:	04 03 09 04                                         ....

000001bc <string1>:
 1bc:	10 03 4d 00 66 00 67 00 4e 00 61 00 6d 00 65 00     ..M.f.g.N.a.m.e.
 1cc:	00 00                                               ..

000001ce <string2>:
 1ce:	12 03 4b 00 65 00 79 00 62 00 6f 00 61 00 72 00     ..K.e.y.b.o.a.r.
 1de:	64 00 00 00                                         d...

000001e2 <__ctors_end>:
 1e2:	11 24       	eor	r1, r1
 1e4:	1f be       	out	0x3f, r1	; 63
 1e6:	cf ef       	ldi	r28, 0xFF	; 255
 1e8:	da e0       	ldi	r29, 0x0A	; 10
 1ea:	de bf       	out	0x3e, r29	; 62
 1ec:	cd bf       	out	0x3d, r28	; 61

000001ee <__do_copy_data>:
 1ee:	11 e0       	ldi	r17, 0x01	; 1
 1f0:	a0 e0       	ldi	r26, 0x00	; 0
 1f2:	b1 e0       	ldi	r27, 0x01	; 1
 1f4:	e2 e3       	ldi	r30, 0x32	; 50
 1f6:	fb e0       	ldi	r31, 0x0B	; 11
 1f8:	02 c0       	rjmp	.+4      	; 0x1fe <.do_copy_data_start>

000001fa <.do_copy_data_loop>:
 1fa:	05 90       	lpm	r0, Z+
 1fc:	0d 92       	st	X+, r0

000001fe <.do_copy_data_start>:
 1fe:	ac 39       	cpi	r26, 0x9C	; 156
 200:	b1 07       	cpc	r27, r17
 202:	d9 f7       	brne	.-10     	; 0x1fa <.do_copy_data_loop>

00000204 <__do_clear_bss>:
 204:	11 e0       	ldi	r17, 0x01	; 1
 206:	ac e9       	ldi	r26, 0x9C	; 156
 208:	b1 e0       	ldi	r27, 0x01	; 1
 20a:	01 c0       	rjmp	.+2      	; 0x20e <.do_clear_bss_start>

0000020c <.do_clear_bss_loop>:
 20c:	1d 92       	st	X+, r1

0000020e <.do_clear_bss_start>:
 20e:	ab 3a       	cpi	r26, 0xAB	; 171
 210:	b1 07       	cpc	r27, r17
 212:	e1 f7       	brne	.-8      	; 0x20c <.do_clear_bss_loop>
 214:	6c d0       	rcall	.+216    	; 0x2ee <main>
 216:	8b c4       	rjmp	.+2326   	; 0xb2e <_exit>

00000218 <__bad_interrupt>:
 218:	f3 ce       	rjmp	.-538    	; 0x0 <__vectors>

0000021a <isModifierKey>:
// KEY RIGHT SHIFT = [12][4]

int isModifierKey(int i, int b)
{
    uint8_t key = 0x00;
    if (b == 0 && i == 4)
 21a:	61 15       	cp	r22, r1
 21c:	71 05       	cpc	r23, r1
 21e:	39 f4       	brne	.+14     	; 0x22e <isModifierKey+0x14>
 220:	84 30       	cpi	r24, 0x04	; 4
 222:	91 05       	cpc	r25, r1
 224:	69 f1       	breq	.+90     	; 0x280 <isModifierKey+0x66>
    {

        key = KEY_LEFT_SHIFT;
    }
    else if (b == 0 && i == 5)
 226:	85 30       	cpi	r24, 0x05	; 5
 228:	91 05       	cpc	r25, r1
 22a:	91 f4       	brne	.+36     	; 0x250 <isModifierKey+0x36>
 22c:	29 c0       	rjmp	.+82     	; 0x280 <isModifierKey+0x66>
    {
        key = KEY_LEFT_CTRL;
    }
    else if (b == 1 && i == 5)
 22e:	61 30       	cpi	r22, 0x01	; 1
 230:	71 05       	cpc	r23, r1
 232:	21 f4       	brne	.+8      	; 0x23c <isModifierKey+0x22>
 234:	85 30       	cpi	r24, 0x05	; 5
 236:	91 05       	cpc	r25, r1
 238:	71 f4       	brne	.+28     	; 0x256 <isModifierKey+0x3c>
 23a:	22 c0       	rjmp	.+68     	; 0x280 <isModifierKey+0x66>
    {
        key = KEY_LEFT_GUI;
    }
    else if (b == 2 && i == 5)
 23c:	62 30       	cpi	r22, 0x02	; 2
 23e:	71 05       	cpc	r23, r1
 240:	21 f4       	brne	.+8      	; 0x24a <isModifierKey+0x30>
 242:	85 30       	cpi	r24, 0x05	; 5
 244:	91 05       	cpc	r25, r1
 246:	91 f4       	brne	.+36     	; 0x26c <isModifierKey+0x52>
 248:	1b c0       	rjmp	.+54     	; 0x280 <isModifierKey+0x66>
    {
        key = KEY_LEFT_ALT;
    }
    else if (b == 8 && i == 5)
 24a:	68 30       	cpi	r22, 0x08	; 8
 24c:	71 05       	cpc	r23, r1
 24e:	31 f0       	breq	.+12     	; 0x25c <isModifierKey+0x42>
    {
        key = KEY_RIGHT_ALT;
    }
    else if (b == 9 && i == 5)
 250:	69 30       	cpi	r22, 0x09	; 9
 252:	71 05       	cpc	r23, r1
 254:	19 f0       	breq	.+6      	; 0x25c <isModifierKey+0x42>
    {
        key = KEY_RIGHT_GUI;
    }
    else if (b == 11 && i == 5)
 256:	6b 30       	cpi	r22, 0x0B	; 11
 258:	71 05       	cpc	r23, r1
 25a:	41 f4       	brne	.+16     	; 0x26c <isModifierKey+0x52>
 25c:	20 e0       	ldi	r18, 0x00	; 0
 25e:	05 97       	sbiw	r24, 0x05	; 5
 260:	09 f0       	breq	.+2      	; 0x264 <isModifierKey+0x4a>
 262:	21 e0       	ldi	r18, 0x01	; 1
 264:	81 e0       	ldi	r24, 0x01	; 1
 266:	28 27       	eor	r18, r24
 268:	30 e0       	ldi	r19, 0x00	; 0
 26a:	0c c0       	rjmp	.+24     	; 0x284 <isModifierKey+0x6a>
    {
        key = KEY_RIGHT_CTRL;
    }
    else if (b == 12 && i == 4)
 26c:	6c 30       	cpi	r22, 0x0C	; 12
 26e:	71 05       	cpc	r23, r1
 270:	19 f0       	breq	.+6      	; 0x278 <isModifierKey+0x5e>
 272:	20 e0       	ldi	r18, 0x00	; 0
 274:	30 e0       	ldi	r19, 0x00	; 0
 276:	06 c0       	rjmp	.+12     	; 0x284 <isModifierKey+0x6a>
 278:	20 e0       	ldi	r18, 0x00	; 0
 27a:	30 e0       	ldi	r19, 0x00	; 0
 27c:	04 97       	sbiw	r24, 0x04	; 4
 27e:	11 f4       	brne	.+4      	; 0x284 <isModifierKey+0x6a>
 280:	21 e0       	ldi	r18, 0x01	; 1
 282:	30 e0       	ldi	r19, 0x00	; 0
    if (key != 0x00)
    {
        return 1;
    }
    return 0;
}
 284:	c9 01       	movw	r24, r18
 286:	08 95       	ret

00000288 <__vector_23>:

// This interrupt routine is run approx 61 times per second.
// A very simple inactivity timeout is implemented, where we
// will send a space character.
ISR(TIMER0_OVF_vect)
{
 288:	1f 92       	push	r1
 28a:	0f 92       	push	r0
 28c:	0f b6       	in	r0, 0x3f	; 63
 28e:	0f 92       	push	r0
 290:	11 24       	eor	r1, r1
 292:	2f 93       	push	r18
 294:	3f 93       	push	r19
 296:	4f 93       	push	r20
 298:	5f 93       	push	r21
 29a:	6f 93       	push	r22
 29c:	7f 93       	push	r23
 29e:	8f 93       	push	r24
 2a0:	9f 93       	push	r25
 2a2:	af 93       	push	r26
 2a4:	bf 93       	push	r27
 2a6:	ef 93       	push	r30
 2a8:	ff 93       	push	r31
    idle_count++;
 2aa:	80 91 9c 01 	lds	r24, 0x019C
 2ae:	90 91 9d 01 	lds	r25, 0x019D
 2b2:	01 96       	adiw	r24, 0x01	; 1
 2b4:	90 93 9d 01 	sts	0x019D, r25
 2b8:	80 93 9c 01 	sts	0x019C, r24
    if (idle_count > 61 * 8)
 2bc:	89 5e       	subi	r24, 0xE9	; 233
 2be:	91 40       	sbci	r25, 0x01	; 1
 2c0:	28 f0       	brcs	.+10     	; 0x2cc <__vector_23+0x44>
    {
        idle_count = 0;
 2c2:	10 92 9d 01 	sts	0x019D, r1
 2c6:	10 92 9c 01 	sts	0x019C, r1
        usb_keyboard_send();
 2ca:	58 d1       	rcall	.+688    	; 0x57c <usb_keyboard_send>
    }
 2cc:	ff 91       	pop	r31
 2ce:	ef 91       	pop	r30
 2d0:	bf 91       	pop	r27
 2d2:	af 91       	pop	r26
 2d4:	9f 91       	pop	r25
 2d6:	8f 91       	pop	r24
 2d8:	7f 91       	pop	r23
 2da:	6f 91       	pop	r22
 2dc:	5f 91       	pop	r21
 2de:	4f 91       	pop	r20
 2e0:	3f 91       	pop	r19
 2e2:	2f 91       	pop	r18
 2e4:	0f 90       	pop	r0
 2e6:	0f be       	out	0x3f, r0	; 63
 2e8:	0f 90       	pop	r0
 2ea:	1f 90       	pop	r1
 2ec:	18 95       	reti

000002ee <main>:
    }
    return 0;
}

int main(void)
{
 2ee:	2f 92       	push	r2
 2f0:	3f 92       	push	r3
 2f2:	5f 92       	push	r5
 2f4:	6f 92       	push	r6
 2f6:	7f 92       	push	r7
 2f8:	8f 92       	push	r8
 2fa:	9f 92       	push	r9
 2fc:	af 92       	push	r10
 2fe:	bf 92       	push	r11
 300:	cf 92       	push	r12
 302:	df 92       	push	r13
 304:	ef 92       	push	r14
 306:	ff 92       	push	r15
 308:	0f 93       	push	r16
 30a:	1f 93       	push	r17
 30c:	df 93       	push	r29
 30e:	cf 93       	push	r28
 310:	cd b7       	in	r28, 0x3d	; 61
 312:	de b7       	in	r29, 0x3e	; 62
 314:	c4 5b       	subi	r28, 0xB4	; 180
 316:	d0 40       	sbci	r29, 0x00	; 0
 318:	0f b6       	in	r0, 0x3f	; 63
 31a:	f8 94       	cli
 31c:	de bf       	out	0x3e, r29	; 62
 31e:	0f be       	out	0x3f, r0	; 63
 320:	cd bf       	out	0x3d, r28	; 61
        7,
        3,
        2,
        1};

    CPU_PRESCALE(0);
 322:	80 e8       	ldi	r24, 0x80	; 128
 324:	80 93 61 00 	sts	0x0061, r24
 328:	10 92 61 00 	sts	0x0061, r1

    usb_init();
 32c:	0d d1       	rcall	.+538    	; 0x548 <usb_init>
    while (!usb_configured())
 32e:	23 d1       	rcall	.+582    	; 0x576 <usb_configured>
 330:	88 23       	and	r24, r24
 332:	e9 f3       	breq	.-6      	; 0x32e <main+0x40>
        ;
    print("usb configured\n");
 334:	80 ec       	ldi	r24, 0xC0	; 192
 336:	90 e0       	ldi	r25, 0x00	; 0
 338:	e6 d3       	rcall	.+1996   	; 0xb06 <print_P>
 33a:	80 e1       	ldi	r24, 0x10	; 16
 33c:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 33e:	20 e9       	ldi	r18, 0x90	; 144
 340:	31 e0       	ldi	r19, 0x01	; 1
 342:	f9 01       	movw	r30, r18
 344:	31 97       	sbiw	r30, 0x01	; 1
 346:	f1 f7       	brne	.-4      	; 0x344 <main+0x56>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 348:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 34a:	d9 f7       	brne	.-10     	; 0x342 <main+0x54>
}

int main(void)
{
    uint8_t reset_idle;
    bool state[6][15] = {0};
 34c:	8a e5       	ldi	r24, 0x5A	; 90
 34e:	de 01       	movw	r26, r28
 350:	11 96       	adiw	r26, 0x01	; 1
 352:	fd 01       	movw	r30, r26
 354:	98 2f       	mov	r25, r24
 356:	11 92       	st	Z+, r1
 358:	9a 95       	dec	r25
 35a:	e9 f7       	brne	.-6      	; 0x356 <main+0x68>
    bool state_prev[6][15] = {0};
 35c:	9e 01       	movw	r18, r28
 35e:	25 5a       	subi	r18, 0xA5	; 165
 360:	3f 4f       	sbci	r19, 0xFF	; 255
 362:	f9 01       	movw	r30, r18
 364:	11 92       	st	Z+, r1
 366:	8a 95       	dec	r24
 368:	e9 f7       	brne	.-6      	; 0x364 <main+0x76>
    // wait for system to become ready
    _delay_ms(1000);

    // Configure timer 0 to generate a timer overflow interrupt every
    // 256*1024 clock cycles, or approx 61 Hz when using 16 MHz clock
    TCCR0A = 0x00;
 36a:	14 bc       	out	0x24, r1	; 36
    TCCR0B = 0x05;
 36c:	85 e0       	ldi	r24, 0x05	; 5
 36e:	85 bd       	out	0x25, r24	; 37
    TIMSK0 = (1 << TOIE0);
 370:	81 e0       	ldi	r24, 0x01	; 1
 372:	80 93 6e 00 	sts	0x006E, r24

    // configure ports 0 = input, 1 = output, 1 = unused (as outputs)
    // columns (inputs): F0 F1 F4 F5 F6 F7 B6 B5 B4 D7 D6 C7 C6 D3 D2
    // rows (outputs): D1 D0 B7 B3 B2 B1
    DDRB = 0b10001111; // 3,2,1 outputs,    6,5,4       inputs,     7,0         unused
 376:	8f e8       	ldi	r24, 0x8F	; 143
 378:	84 b9       	out	0x04, r24	; 4
    DDRC = 0b00111111; //       outputs,    7,6         inputs,     5,4,3,2,1,0 unused
 37a:	8f e3       	ldi	r24, 0x3F	; 63
 37c:	87 b9       	out	0x07, r24	; 7
    DDRD = 0b01110011; // 1,0   outputs,    7,3,2       inputs,     4,5,6       unused
 37e:	83 e7       	ldi	r24, 0x73	; 115
 380:	8a b9       	out	0x0a, r24	; 10
    DDRF = 0b00001100; //       outputs,    0,1,4,5,6,7 inputs,     2,3         unused
 382:	8c e0       	ldi	r24, 0x0C	; 12
 384:	80 bb       	out	0x10, r24	; 16

    while (1)
    {
        print("\nmain loop started\n");
        // set all pins high
        PORTB = 0xff;
 386:	55 24       	eor	r5, r5
 388:	5a 94       	dec	r5
        PORTF = 0xff;
        // read all ports
        for (int i = 0; i < 6; i++)
        {
            // set i:th row low
            *(outputRows[i]) &= ~(0x01 << outputRowShifts[i]);
 38a:	1d 01       	movw	r2, r26
    DDRD = 0b01110011; // 1,0   outputs,    7,3,2       inputs,     4,5,6       unused
    DDRF = 0b00001100; //       outputs,    0,1,4,5,6,7 inputs,     2,3         unused

    while (1)
    {
        print("\nmain loop started\n");
 38c:	8c ea       	ldi	r24, 0xAC	; 172
 38e:	90 e0       	ldi	r25, 0x00	; 0
 390:	ba d3       	rcall	.+1908   	; 0xb06 <print_P>
        // set all pins high
        PORTB = 0xff;
 392:	55 b8       	out	0x05, r5	; 5
        PORTC = 0xff;
 394:	58 b8       	out	0x08, r5	; 8
        PORTD = 0xff;
 396:	5b b8       	out	0x0b, r5	; 11
        PORTF = 0xff;
 398:	51 ba       	out	0x11, r5	; 17
 39a:	40 e0       	ldi	r20, 0x00	; 0
 39c:	50 e0       	ldi	r21, 0x00	; 0
        // read all ports
        for (int i = 0; i < 6; i++)
        {
            // set i:th row low
            *(outputRows[i]) &= ~(0x01 << outputRowShifts[i]);
 39e:	fa 01       	movw	r30, r20
 3a0:	ee 0f       	add	r30, r30
 3a2:	ff 1f       	adc	r31, r31
 3a4:	e0 5a       	subi	r30, 0xA0	; 160
 3a6:	fe 4f       	sbci	r31, 0xFE	; 254
 3a8:	a0 81       	ld	r26, Z
 3aa:	b1 81       	ldd	r27, Z+1	; 0x01
 3ac:	fa 01       	movw	r30, r20
 3ae:	e6 5a       	subi	r30, 0xA6	; 166
 3b0:	fe 4f       	sbci	r31, 0xFE	; 254
 3b2:	81 e0       	ldi	r24, 0x01	; 1
 3b4:	90 e0       	ldi	r25, 0x00	; 0
 3b6:	00 80       	ld	r0, Z
 3b8:	02 c0       	rjmp	.+4      	; 0x3be <main+0xd0>
 3ba:	88 0f       	add	r24, r24
 3bc:	99 1f       	adc	r25, r25
 3be:	0a 94       	dec	r0
 3c0:	e2 f7       	brpl	.-8      	; 0x3ba <main+0xcc>
 3c2:	68 2f       	mov	r22, r24
 3c4:	98 2f       	mov	r25, r24
 3c6:	90 95       	com	r25
 3c8:	8c 91       	ld	r24, X
 3ca:	89 23       	and	r24, r25
 3cc:	8c 93       	st	X, r24
 3ce:	da 01       	movw	r26, r20
 3d0:	04 e0       	ldi	r16, 0x04	; 4
 3d2:	aa 0f       	add	r26, r26
 3d4:	bb 1f       	adc	r27, r27
 3d6:	0a 95       	dec	r16
 3d8:	e1 f7       	brne	.-8      	; 0x3d2 <main+0xe4>
 3da:	a4 1b       	sub	r26, r20
 3dc:	b5 0b       	sbc	r27, r21
 3de:	a2 0d       	add	r26, r2
 3e0:	b3 1d       	adc	r27, r3
 3e2:	20 e0       	ldi	r18, 0x00	; 0
 3e4:	30 e0       	ldi	r19, 0x00	; 0

            // check all columns
            for (int b = 0; b < 15; b++)
            {
                state[i][b] = (*(inputColumns[b]) >> inputColumnShifts[b]) & 0x01;
 3e6:	f9 01       	movw	r30, r18
 3e8:	ee 0f       	add	r30, r30
 3ea:	ff 1f       	adc	r31, r31
 3ec:	e5 58       	subi	r30, 0x85	; 133
 3ee:	fe 4f       	sbci	r31, 0xFE	; 254
 3f0:	01 90       	ld	r0, Z+
 3f2:	f0 81       	ld	r31, Z
 3f4:	e0 2d       	mov	r30, r0
 3f6:	80 81       	ld	r24, Z
 3f8:	90 e0       	ldi	r25, 0x00	; 0
 3fa:	f9 01       	movw	r30, r18
 3fc:	e4 59       	subi	r30, 0x94	; 148
 3fe:	fe 4f       	sbci	r31, 0xFE	; 254
 400:	00 80       	ld	r0, Z
 402:	02 c0       	rjmp	.+4      	; 0x408 <main+0x11a>
 404:	95 95       	asr	r25
 406:	87 95       	ror	r24
 408:	0a 94       	dec	r0
 40a:	e2 f7       	brpl	.-8      	; 0x404 <main+0x116>
 40c:	81 70       	andi	r24, 0x01	; 1
 40e:	90 70       	andi	r25, 0x00	; 0
 410:	8d 93       	st	X+, r24
        {
            // set i:th row low
            *(outputRows[i]) &= ~(0x01 << outputRowShifts[i]);

            // check all columns
            for (int b = 0; b < 15; b++)
 412:	2f 5f       	subi	r18, 0xFF	; 255
 414:	3f 4f       	sbci	r19, 0xFF	; 255
 416:	2f 30       	cpi	r18, 0x0F	; 15
 418:	31 05       	cpc	r19, r1
 41a:	29 f7       	brne	.-54     	; 0x3e6 <main+0xf8>
            {
                state[i][b] = (*(inputColumns[b]) >> inputColumnShifts[b]) & 0x01;
            }
            // set i:th row back high
            *(outputRows[i]) |= (0x01 << outputRowShifts[i]);
 41c:	fa 01       	movw	r30, r20
 41e:	ee 0f       	add	r30, r30
 420:	ff 1f       	adc	r31, r31
 422:	e0 5a       	subi	r30, 0xA0	; 160
 424:	fe 4f       	sbci	r31, 0xFE	; 254
 426:	01 90       	ld	r0, Z+
 428:	f0 81       	ld	r31, Z
 42a:	e0 2d       	mov	r30, r0
 42c:	80 81       	ld	r24, Z
 42e:	86 2b       	or	r24, r22
 430:	80 83       	st	Z, r24
        PORTB = 0xff;
        PORTC = 0xff;
        PORTD = 0xff;
        PORTF = 0xff;
        // read all ports
        for (int i = 0; i < 6; i++)
 432:	4f 5f       	subi	r20, 0xFF	; 255
 434:	5f 4f       	sbci	r21, 0xFF	; 255
 436:	46 30       	cpi	r20, 0x06	; 6
 438:	51 05       	cpc	r21, r1
 43a:	09 f0       	breq	.+2      	; 0x43e <main+0x150>
 43c:	b0 cf       	rjmp	.-160    	; 0x39e <main+0xb0>
 43e:	70 90 9e 01 	lds	r7, 0x019E
 442:	00 e0       	ldi	r16, 0x00	; 0
 444:	10 e0       	ldi	r17, 0x00	; 0
 446:	57 c0       	rjmp	.+174    	; 0x4f6 <main+0x208>
        // sum logic for tracking changes
        for (int i = 0; i < 6; i++)
        {
            for (int b = 0; b < 15; b++)
            {
                if (state[i][b] && state_prev[i][b])
 448:	d4 01       	movw	r26, r8
 44a:	6c 90       	ld	r6, X
 44c:	f5 01       	movw	r30, r10
 44e:	80 81       	ld	r24, Z
 450:	66 20       	and	r6, r6
 452:	e9 f0       	breq	.+58     	; 0x48e <main+0x1a0>
 454:	88 23       	and	r24, r24
 456:	c1 f1       	breq	.+112    	; 0x4c8 <main+0x1da>
                {
                    reset_idle = 1;
                    if (isModifierKey(i, b))
 458:	c8 01       	movw	r24, r16
 45a:	b7 01       	movw	r22, r14
 45c:	de de       	rcall	.-580    	; 0x21a <isModifierKey>
 45e:	d6 01       	movw	r26, r12
 460:	4c 91       	ld	r20, X
 462:	89 2b       	or	r24, r25
 464:	19 f0       	breq	.+6      	; 0x46c <main+0x17e>
                    {
                        // reversed because of pull up
                        keyboard_modifier_keys &= ~(keys[b][i]);
 466:	40 95       	com	r20
 468:	74 22       	and	r7, r20
 46a:	2e c0       	rjmp	.+92     	; 0x4c8 <main+0x1da>
                    }
                    else
                    {
                        for (int d = 0; d < 6; d++)
                        {
                            if (keyboard_keys[d] == keys[b][i])
 46c:	20 e0       	ldi	r18, 0x00	; 0
 46e:	30 e0       	ldi	r19, 0x00	; 0
 470:	f9 01       	movw	r30, r18
 472:	e1 56       	subi	r30, 0x61	; 97
 474:	fe 4f       	sbci	r31, 0xFE	; 254
 476:	80 81       	ld	r24, Z
 478:	84 17       	cp	r24, r20
 47a:	19 f4       	brne	.+6      	; 0x482 <main+0x194>
                            {
                                // reversed because of pull up
                                keyboard_keys[d] = 0x00;
 47c:	10 82       	st	Z, r1
 47e:	25 e0       	ldi	r18, 0x05	; 5
 480:	30 e0       	ldi	r19, 0x00	; 0
                        // reversed because of pull up
                        keyboard_modifier_keys &= ~(keys[b][i]);
                    }
                    else
                    {
                        for (int d = 0; d < 6; d++)
 482:	2f 5f       	subi	r18, 0xFF	; 255
 484:	3f 4f       	sbci	r19, 0xFF	; 255
 486:	26 30       	cpi	r18, 0x06	; 6
 488:	31 05       	cpc	r19, r1
 48a:	91 f7       	brne	.-28     	; 0x470 <main+0x182>
 48c:	1d c0       	rjmp	.+58     	; 0x4c8 <main+0x1da>
                                d = 5;
                            }
                        }
                    }
                }
                if (!state[i][b] && !state_prev[i][b])
 48e:	88 23       	and	r24, r24
 490:	d9 f4       	brne	.+54     	; 0x4c8 <main+0x1da>
                {
                    if (isModifierKey(i, b))
 492:	c8 01       	movw	r24, r16
 494:	b7 01       	movw	r22, r14
 496:	c1 de       	rcall	.-638    	; 0x21a <isModifierKey>
 498:	89 2b       	or	r24, r25
 49a:	21 f0       	breq	.+8      	; 0x4a4 <main+0x1b6>
                    {
                        // reversed because of pull up
                        keyboard_modifier_keys |= keys[b][i];
 49c:	f6 01       	movw	r30, r12
 49e:	80 81       	ld	r24, Z
 4a0:	78 2a       	or	r7, r24
 4a2:	12 c0       	rjmp	.+36     	; 0x4c8 <main+0x1da>
 4a4:	20 e0       	ldi	r18, 0x00	; 0
 4a6:	30 e0       	ldi	r19, 0x00	; 0
                    }
                    else
                    {
                        for (int d = 0; d < 6; d++)
                        {
                            if (keyboard_keys[d] == 0x00)
 4a8:	f9 01       	movw	r30, r18
 4aa:	e1 56       	subi	r30, 0x61	; 97
 4ac:	fe 4f       	sbci	r31, 0xFE	; 254
 4ae:	80 81       	ld	r24, Z
 4b0:	88 23       	and	r24, r24
 4b2:	29 f4       	brne	.+10     	; 0x4be <main+0x1d0>
                            {
                                // reversed because of pull up
                                keyboard_keys[d] = keys[b][i];
 4b4:	d6 01       	movw	r26, r12
 4b6:	8c 91       	ld	r24, X
 4b8:	80 83       	st	Z, r24
 4ba:	25 e0       	ldi	r18, 0x05	; 5
 4bc:	30 e0       	ldi	r19, 0x00	; 0
                        // reversed because of pull up
                        keyboard_modifier_keys |= keys[b][i];
                    }
                    else
                    {
                        for (int d = 0; d < 6; d++)
 4be:	2f 5f       	subi	r18, 0xFF	; 255
 4c0:	3f 4f       	sbci	r19, 0xFF	; 255
 4c2:	26 30       	cpi	r18, 0x06	; 6
 4c4:	31 05       	cpc	r19, r1
 4c6:	81 f7       	brne	.-32     	; 0x4a8 <main+0x1ba>
                                d = 5;
                            }
                        }
                    }
                }
                state_prev[i][b] = state[i][b];
 4c8:	f5 01       	movw	r30, r10
 4ca:	61 92       	st	Z+, r6
 4cc:	5f 01       	movw	r10, r30
            *(outputRows[i]) |= (0x01 << outputRowShifts[i]);
        }
        // sum logic for tracking changes
        for (int i = 0; i < 6; i++)
        {
            for (int b = 0; b < 15; b++)
 4ce:	08 94       	sec
 4d0:	e1 1c       	adc	r14, r1
 4d2:	f1 1c       	adc	r15, r1
 4d4:	08 94       	sec
 4d6:	81 1c       	adc	r8, r1
 4d8:	91 1c       	adc	r9, r1
 4da:	86 e0       	ldi	r24, 0x06	; 6
 4dc:	90 e0       	ldi	r25, 0x00	; 0
 4de:	c8 0e       	add	r12, r24
 4e0:	d9 1e       	adc	r13, r25
 4e2:	9f e0       	ldi	r25, 0x0F	; 15
 4e4:	e9 16       	cp	r14, r25
 4e6:	f1 04       	cpc	r15, r1
 4e8:	09 f0       	breq	.+2      	; 0x4ec <main+0x1fe>
 4ea:	ae cf       	rjmp	.-164    	; 0x448 <main+0x15a>
            }
            // set i:th row back high
            *(outputRows[i]) |= (0x01 << outputRowShifts[i]);
        }
        // sum logic for tracking changes
        for (int i = 0; i < 6; i++)
 4ec:	0f 5f       	subi	r16, 0xFF	; 255
 4ee:	1f 4f       	sbci	r17, 0xFF	; 255
 4f0:	06 30       	cpi	r16, 0x06	; 6
 4f2:	11 05       	cpc	r17, r1
 4f4:	d9 f0       	breq	.+54     	; 0x52c <main+0x23e>
 4f6:	c8 01       	movw	r24, r16
 4f8:	34 e0       	ldi	r19, 0x04	; 4
 4fa:	88 0f       	add	r24, r24
 4fc:	99 1f       	adc	r25, r25
 4fe:	3a 95       	dec	r19
 500:	e1 f7       	brne	.-8      	; 0x4fa <main+0x20c>
 502:	80 1b       	sub	r24, r16
 504:	91 0b       	sbc	r25, r17
 506:	41 01       	movw	r8, r2
 508:	88 0e       	add	r8, r24
 50a:	99 1e       	adc	r9, r25
 50c:	2b e5       	ldi	r18, 0x5B	; 91
 50e:	a2 2e       	mov	r10, r18
 510:	b1 2c       	mov	r11, r1
 512:	ac 0e       	add	r10, r28
 514:	bd 1e       	adc	r11, r29
 516:	a8 0e       	add	r10, r24
 518:	b9 1e       	adc	r11, r25
 51a:	80 e0       	ldi	r24, 0x00	; 0
 51c:	c8 2e       	mov	r12, r24
 51e:	81 e0       	ldi	r24, 0x01	; 1
 520:	d8 2e       	mov	r13, r24
 522:	c0 0e       	add	r12, r16
 524:	d1 1e       	adc	r13, r17
 526:	ee 24       	eor	r14, r14
 528:	ff 24       	eor	r15, r15
 52a:	8e cf       	rjmp	.-228    	; 0x448 <main+0x15a>
 52c:	70 92 9e 01 	sts	0x019E, r7
                state_prev[i][b] = state[i][b];
            }
        }
        if (reset_idle)
        {
            cli();
 530:	f8 94       	cli
            idle_count = 0;
 532:	10 92 9d 01 	sts	0x019D, r1
 536:	10 92 9c 01 	sts	0x019C, r1
            sei();
 53a:	78 94       	sei
 53c:	80 e4       	ldi	r24, 0x40	; 64
 53e:	9f e1       	ldi	r25, 0x1F	; 31
 540:	01 97       	sbiw	r24, 0x01	; 1
 542:	f1 f7       	brne	.-4      	; 0x540 <main+0x252>
            _delay_ms(2);
        }
        usb_keyboard_send();
 544:	1b d0       	rcall	.+54     	; 0x57c <usb_keyboard_send>
 546:	22 cf       	rjmp	.-444    	; 0x38c <main+0x9e>

00000548 <usb_init>:


// initialize USB
void usb_init(void)
{
	HW_CONFIG();
 548:	81 e0       	ldi	r24, 0x01	; 1
 54a:	80 93 d7 00 	sts	0x00D7, r24
	USB_FREEZE();				// enable USB
 54e:	80 ea       	ldi	r24, 0xA0	; 160
 550:	80 93 d8 00 	sts	0x00D8, r24
	PLL_CONFIG();				// config PLL
 554:	82 e1       	ldi	r24, 0x12	; 18
 556:	89 bd       	out	0x29, r24	; 41
        while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
 558:	09 b4       	in	r0, 0x29	; 41
 55a:	00 fe       	sbrs	r0, 0
 55c:	fd cf       	rjmp	.-6      	; 0x558 <usb_init+0x10>
        USB_CONFIG();				// start USB clock
 55e:	80 e9       	ldi	r24, 0x90	; 144
 560:	80 93 d8 00 	sts	0x00D8, r24
        UDCON = 0;				// enable attach resistor
 564:	10 92 e0 00 	sts	0x00E0, r1
	usb_configuration = 0;
 568:	10 92 a6 01 	sts	0x01A6, r1
        UDIEN = (1<<EORSTE)|(1<<SOFE);
 56c:	8c e0       	ldi	r24, 0x0C	; 12
 56e:	80 93 e2 00 	sts	0x00E2, r24
	sei();
 572:	78 94       	sei
}
 574:	08 95       	ret

00000576 <usb_configured>:

// return 0 if the USB is not configured, or the configuration
// number selected by the HOST
uint8_t usb_configured(void)
{
	return usb_configuration;
 576:	80 91 a6 01 	lds	r24, 0x01A6
}
 57a:	08 95       	ret

0000057c <usb_keyboard_send>:
// send the contents of keyboard_keys and keyboard_modifier_keys
int8_t usb_keyboard_send(void)
{
	uint8_t i, intr_state, timeout;

	if (!usb_configuration) return -1;
 57c:	80 91 a6 01 	lds	r24, 0x01A6
 580:	88 23       	and	r24, r24
 582:	09 f4       	brne	.+2      	; 0x586 <usb_keyboard_send+0xa>
 584:	41 c0       	rjmp	.+130    	; 0x608 <usb_keyboard_send+0x8c>
	intr_state = SREG;
 586:	2f b7       	in	r18, 0x3f	; 63
	cli();
 588:	f8 94       	cli
	UENUM = KEYBOARD_ENDPOINT;
 58a:	83 e0       	ldi	r24, 0x03	; 3
 58c:	80 93 e9 00 	sts	0x00E9, r24
	timeout = UDFNUML + 50;
 590:	90 91 e4 00 	lds	r25, 0x00E4
 594:	9e 5c       	subi	r25, 0xCE	; 206
		// have we waited too long?
		if (UDFNUML == timeout) return -1;
		// get ready to try checking again
		intr_state = SREG;
		cli();
		UENUM = KEYBOARD_ENDPOINT;
 596:	33 e0       	ldi	r19, 0x03	; 3
	cli();
	UENUM = KEYBOARD_ENDPOINT;
	timeout = UDFNUML + 50;
	while (1) {
		// are we ready to transmit?
		if (UEINTX & (1<<RWAL)) break;
 598:	80 91 e8 00 	lds	r24, 0x00E8
 59c:	85 fd       	sbrc	r24, 5
 59e:	0e c0       	rjmp	.+28     	; 0x5bc <usb_keyboard_send+0x40>
		SREG = intr_state;
 5a0:	2f bf       	out	0x3f, r18	; 63
		// has the USB gone offline?
		if (!usb_configuration) return -1;
 5a2:	80 91 a6 01 	lds	r24, 0x01A6
 5a6:	88 23       	and	r24, r24
 5a8:	79 f1       	breq	.+94     	; 0x608 <usb_keyboard_send+0x8c>
		// have we waited too long?
		if (UDFNUML == timeout) return -1;
 5aa:	80 91 e4 00 	lds	r24, 0x00E4
 5ae:	89 17       	cp	r24, r25
 5b0:	59 f1       	breq	.+86     	; 0x608 <usb_keyboard_send+0x8c>
		// get ready to try checking again
		intr_state = SREG;
 5b2:	2f b7       	in	r18, 0x3f	; 63
		cli();
 5b4:	f8 94       	cli
		UENUM = KEYBOARD_ENDPOINT;
 5b6:	30 93 e9 00 	sts	0x00E9, r19
 5ba:	ee cf       	rjmp	.-36     	; 0x598 <usb_keyboard_send+0x1c>
	}
	UEDATX = keyboard_modifier_keys;
 5bc:	80 91 9e 01 	lds	r24, 0x019E
 5c0:	80 93 f1 00 	sts	0x00F1, r24
	UEDATX = 0;
 5c4:	10 92 f1 00 	sts	0x00F1, r1
	for (i=0; i<6; i++) {
		UEDATX = keyboard_keys[i];
 5c8:	80 91 9f 01 	lds	r24, 0x019F
 5cc:	80 93 f1 00 	sts	0x00F1, r24
 5d0:	80 91 a0 01 	lds	r24, 0x01A0
 5d4:	80 93 f1 00 	sts	0x00F1, r24
 5d8:	80 91 a1 01 	lds	r24, 0x01A1
 5dc:	80 93 f1 00 	sts	0x00F1, r24
 5e0:	80 91 a2 01 	lds	r24, 0x01A2
 5e4:	80 93 f1 00 	sts	0x00F1, r24
 5e8:	80 91 a3 01 	lds	r24, 0x01A3
 5ec:	80 93 f1 00 	sts	0x00F1, r24
 5f0:	80 91 a4 01 	lds	r24, 0x01A4
 5f4:	80 93 f1 00 	sts	0x00F1, r24
	}
	UEINTX = 0x3A;
 5f8:	8a e3       	ldi	r24, 0x3A	; 58
 5fa:	80 93 e8 00 	sts	0x00E8, r24
	keyboard_idle_count = 0;
 5fe:	10 92 a7 01 	sts	0x01A7, r1
	SREG = intr_state;
 602:	2f bf       	out	0x3f, r18	; 63
 604:	80 e0       	ldi	r24, 0x00	; 0
 606:	08 95       	ret
	return 0;
 608:	8f ef       	ldi	r24, 0xFF	; 255
}
 60a:	08 95       	ret

0000060c <usb_debug_putchar>:

// transmit a character.  0 returned on success, -1 on error
int8_t usb_debug_putchar(uint8_t c)
{
 60c:	48 2f       	mov	r20, r24
	static uint8_t previous_timeout=0;
	uint8_t timeout, intr_state;

	// if we're not online (enumerated and configured), error
	if (!usb_configuration) return -1;
 60e:	80 91 a6 01 	lds	r24, 0x01A6
 612:	88 23       	and	r24, r24
 614:	09 f4       	brne	.+2      	; 0x618 <usb_debug_putchar+0xc>
 616:	3e c0       	rjmp	.+124    	; 0x694 <usb_debug_putchar+0x88>
	// interrupts are disabled so these functions can be
	// used from the main program or interrupt context,
	// even both in the same program!
	intr_state = SREG;
 618:	2f b7       	in	r18, 0x3f	; 63
	cli();
 61a:	f8 94       	cli
	UENUM = DEBUG_TX_ENDPOINT;
 61c:	84 e0       	ldi	r24, 0x04	; 4
 61e:	80 93 e9 00 	sts	0x00E9, r24
	// if we gave up due to timeout before, don't wait again
	if (previous_timeout) {
 622:	80 91 aa 01 	lds	r24, 0x01AA
 626:	88 23       	and	r24, r24
 628:	41 f0       	breq	.+16     	; 0x63a <usb_debug_putchar+0x2e>
		if (!(UEINTX & (1<<RWAL))) {
 62a:	80 91 e8 00 	lds	r24, 0x00E8
 62e:	85 fd       	sbrc	r24, 5
 630:	02 c0       	rjmp	.+4      	; 0x636 <usb_debug_putchar+0x2a>
			SREG = intr_state;
 632:	2f bf       	out	0x3f, r18	; 63
 634:	12 c0       	rjmp	.+36     	; 0x65a <usb_debug_putchar+0x4e>
			return -1;
		}
		previous_timeout = 0;
 636:	10 92 aa 01 	sts	0x01AA, r1
	}
	// wait for the FIFO to be ready to accept data
	timeout = UDFNUML + 4;
 63a:	90 91 e4 00 	lds	r25, 0x00E4
 63e:	9c 5f       	subi	r25, 0xFC	; 252
		// has the USB gone offline?
		if (!usb_configuration) return -1;
		// get ready to try checking again
		intr_state = SREG;
		cli();
		UENUM = DEBUG_TX_ENDPOINT;
 640:	34 e0       	ldi	r19, 0x04	; 4
	}
	// wait for the FIFO to be ready to accept data
	timeout = UDFNUML + 4;
	while (1) {
		// are we ready to transmit?
		if (UEINTX & (1<<RWAL)) break;
 642:	80 91 e8 00 	lds	r24, 0x00E8
 646:	85 fd       	sbrc	r24, 5
 648:	13 c0       	rjmp	.+38     	; 0x670 <usb_debug_putchar+0x64>
		SREG = intr_state;
 64a:	2f bf       	out	0x3f, r18	; 63
		// have we waited too long?
		if (UDFNUML == timeout) {
 64c:	80 91 e4 00 	lds	r24, 0x00E4
 650:	89 17       	cp	r24, r25
 652:	29 f4       	brne	.+10     	; 0x65e <usb_debug_putchar+0x52>
			previous_timeout = 1;
 654:	81 e0       	ldi	r24, 0x01	; 1
 656:	80 93 aa 01 	sts	0x01AA, r24
 65a:	8f ef       	ldi	r24, 0xFF	; 255
 65c:	08 95       	ret
			return -1;
		}
		// has the USB gone offline?
		if (!usb_configuration) return -1;
 65e:	80 91 a6 01 	lds	r24, 0x01A6
 662:	88 23       	and	r24, r24
 664:	b9 f0       	breq	.+46     	; 0x694 <usb_debug_putchar+0x88>
		// get ready to try checking again
		intr_state = SREG;
 666:	2f b7       	in	r18, 0x3f	; 63
		cli();
 668:	f8 94       	cli
		UENUM = DEBUG_TX_ENDPOINT;
 66a:	30 93 e9 00 	sts	0x00E9, r19
 66e:	e9 cf       	rjmp	.-46     	; 0x642 <usb_debug_putchar+0x36>
	}
	// actually write the byte into the FIFO
	UEDATX = c;
 670:	40 93 f1 00 	sts	0x00F1, r20
	// if this completed a packet, transmit it now!
	if (!(UEINTX & (1<<RWAL))) {
 674:	80 91 e8 00 	lds	r24, 0x00E8
 678:	85 fd       	sbrc	r24, 5
 67a:	06 c0       	rjmp	.+12     	; 0x688 <usb_debug_putchar+0x7c>
		UEINTX = 0x3A;
 67c:	8a e3       	ldi	r24, 0x3A	; 58
 67e:	80 93 e8 00 	sts	0x00E8, r24
		debug_flush_timer = 0;
 682:	10 92 a8 01 	sts	0x01A8, r1
 686:	03 c0       	rjmp	.+6      	; 0x68e <usb_debug_putchar+0x82>
	} else {
		debug_flush_timer = 2;
 688:	82 e0       	ldi	r24, 0x02	; 2
 68a:	80 93 a8 01 	sts	0x01A8, r24
	}
	SREG = intr_state;
 68e:	2f bf       	out	0x3f, r18	; 63
 690:	80 e0       	ldi	r24, 0x00	; 0
 692:	08 95       	ret
	return 0;
 694:	8f ef       	ldi	r24, 0xFF	; 255
}
 696:	08 95       	ret

00000698 <__vector_10>:

// USB Device Interrupt - handle all device-level events
// the transmit buffer flushing is triggered by the start of frame
//
ISR(USB_GEN_vect)
{
 698:	1f 92       	push	r1
 69a:	0f 92       	push	r0
 69c:	0f b6       	in	r0, 0x3f	; 63
 69e:	0f 92       	push	r0
 6a0:	11 24       	eor	r1, r1
 6a2:	2f 93       	push	r18
 6a4:	8f 93       	push	r24
 6a6:	9f 93       	push	r25
	uint8_t intbits, t, i;
	static uint8_t div4=0;

        intbits = UDINT;
 6a8:	80 91 e1 00 	lds	r24, 0x00E1
        UDINT = 0;
 6ac:	10 92 e1 00 	sts	0x00E1, r1
        if (intbits & (1<<EORSTI)) {
 6b0:	98 2f       	mov	r25, r24
 6b2:	83 ff       	sbrs	r24, 3
 6b4:	0f c0       	rjmp	.+30     	; 0x6d4 <__vector_10+0x3c>
		UENUM = 0;
 6b6:	10 92 e9 00 	sts	0x00E9, r1
		UECONX = 1;
 6ba:	81 e0       	ldi	r24, 0x01	; 1
 6bc:	80 93 eb 00 	sts	0x00EB, r24
		UECFG0X = EP_TYPE_CONTROL;
 6c0:	10 92 ec 00 	sts	0x00EC, r1
		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 6c4:	82 e2       	ldi	r24, 0x22	; 34
 6c6:	80 93 ed 00 	sts	0x00ED, r24
		UEIENX = (1<<RXSTPE);
 6ca:	88 e0       	ldi	r24, 0x08	; 8
 6cc:	80 93 f0 00 	sts	0x00F0, r24
		usb_configuration = 0;
 6d0:	10 92 a6 01 	sts	0x01A6, r1
        }
	if ((intbits & (1<<SOFI)) && usb_configuration) {
 6d4:	92 ff       	sbrs	r25, 2
 6d6:	5a c0       	rjmp	.+180    	; 0x78c <__vector_10+0xf4>
 6d8:	80 91 a6 01 	lds	r24, 0x01A6
 6dc:	88 23       	and	r24, r24
 6de:	09 f4       	brne	.+2      	; 0x6e2 <__vector_10+0x4a>
 6e0:	55 c0       	rjmp	.+170    	; 0x78c <__vector_10+0xf4>
		t = debug_flush_timer;
 6e2:	80 91 a8 01 	lds	r24, 0x01A8
		if (t) {
 6e6:	88 23       	and	r24, r24
 6e8:	91 f0       	breq	.+36     	; 0x70e <__vector_10+0x76>
			debug_flush_timer = -- t;
 6ea:	81 50       	subi	r24, 0x01	; 1
 6ec:	80 93 a8 01 	sts	0x01A8, r24
			if (!t) {
 6f0:	88 23       	and	r24, r24
 6f2:	69 f4       	brne	.+26     	; 0x70e <__vector_10+0x76>
				UENUM = DEBUG_TX_ENDPOINT;
 6f4:	84 e0       	ldi	r24, 0x04	; 4
 6f6:	80 93 e9 00 	sts	0x00E9, r24
 6fa:	02 c0       	rjmp	.+4      	; 0x700 <__vector_10+0x68>
				while ((UEINTX & (1<<RWAL))) {
					UEDATX = 0;
 6fc:	10 92 f1 00 	sts	0x00F1, r1
		t = debug_flush_timer;
		if (t) {
			debug_flush_timer = -- t;
			if (!t) {
				UENUM = DEBUG_TX_ENDPOINT;
				while ((UEINTX & (1<<RWAL))) {
 700:	80 91 e8 00 	lds	r24, 0x00E8
 704:	85 fd       	sbrc	r24, 5
 706:	fa cf       	rjmp	.-12     	; 0x6fc <__vector_10+0x64>
					UEDATX = 0;
				}
				UEINTX = 0x3A;
 708:	8a e3       	ldi	r24, 0x3A	; 58
 70a:	80 93 e8 00 	sts	0x00E8, r24
			}
		}
		if (keyboard_idle_config && (++div4 & 3) == 0) {
 70e:	20 91 99 01 	lds	r18, 0x0199
 712:	22 23       	and	r18, r18
 714:	d9 f1       	breq	.+118    	; 0x78c <__vector_10+0xf4>
 716:	80 91 a9 01 	lds	r24, 0x01A9
 71a:	8f 5f       	subi	r24, 0xFF	; 255
 71c:	80 93 a9 01 	sts	0x01A9, r24
 720:	90 e0       	ldi	r25, 0x00	; 0
 722:	83 70       	andi	r24, 0x03	; 3
 724:	90 70       	andi	r25, 0x00	; 0
 726:	89 2b       	or	r24, r25
 728:	89 f5       	brne	.+98     	; 0x78c <__vector_10+0xf4>
			UENUM = KEYBOARD_ENDPOINT;
 72a:	83 e0       	ldi	r24, 0x03	; 3
 72c:	80 93 e9 00 	sts	0x00E9, r24
			if (UEINTX & (1<<RWAL)) {
 730:	80 91 e8 00 	lds	r24, 0x00E8
 734:	85 ff       	sbrs	r24, 5
 736:	2a c0       	rjmp	.+84     	; 0x78c <__vector_10+0xf4>
				keyboard_idle_count++;
 738:	80 91 a7 01 	lds	r24, 0x01A7
 73c:	8f 5f       	subi	r24, 0xFF	; 255
 73e:	80 93 a7 01 	sts	0x01A7, r24
				if (keyboard_idle_count == keyboard_idle_config) {
 742:	82 17       	cp	r24, r18
 744:	19 f5       	brne	.+70     	; 0x78c <__vector_10+0xf4>
					keyboard_idle_count = 0;
 746:	10 92 a7 01 	sts	0x01A7, r1
					UEDATX = keyboard_modifier_keys;
 74a:	80 91 9e 01 	lds	r24, 0x019E
 74e:	80 93 f1 00 	sts	0x00F1, r24
					UEDATX = 0;
 752:	10 92 f1 00 	sts	0x00F1, r1
					for (i=0; i<6; i++) {
						UEDATX = keyboard_keys[i];
 756:	80 91 9f 01 	lds	r24, 0x019F
 75a:	80 93 f1 00 	sts	0x00F1, r24
 75e:	80 91 a0 01 	lds	r24, 0x01A0
 762:	80 93 f1 00 	sts	0x00F1, r24
 766:	80 91 a1 01 	lds	r24, 0x01A1
 76a:	80 93 f1 00 	sts	0x00F1, r24
 76e:	80 91 a2 01 	lds	r24, 0x01A2
 772:	80 93 f1 00 	sts	0x00F1, r24
 776:	80 91 a3 01 	lds	r24, 0x01A3
 77a:	80 93 f1 00 	sts	0x00F1, r24
 77e:	80 91 a4 01 	lds	r24, 0x01A4
 782:	80 93 f1 00 	sts	0x00F1, r24
					}
					UEINTX = 0x3A;
 786:	8a e3       	ldi	r24, 0x3A	; 58
 788:	80 93 e8 00 	sts	0x00E8, r24
				}
			}
		}
	}
}
 78c:	9f 91       	pop	r25
 78e:	8f 91       	pop	r24
 790:	2f 91       	pop	r18
 792:	0f 90       	pop	r0
 794:	0f be       	out	0x3f, r0	; 63
 796:	0f 90       	pop	r0
 798:	1f 90       	pop	r1
 79a:	18 95       	reti

0000079c <__vector_11>:
// USB Endpoint Interrupt - endpoint 0 is handled here.  The
// other endpoints are manipulated by the user-callable
// functions, and the start-of-frame interrupt.
//
ISR(USB_COM_vect)
{
 79c:	1f 92       	push	r1
 79e:	0f 92       	push	r0
 7a0:	0f b6       	in	r0, 0x3f	; 63
 7a2:	0f 92       	push	r0
 7a4:	11 24       	eor	r1, r1
 7a6:	2f 93       	push	r18
 7a8:	3f 93       	push	r19
 7aa:	4f 93       	push	r20
 7ac:	5f 93       	push	r21
 7ae:	6f 93       	push	r22
 7b0:	7f 93       	push	r23
 7b2:	8f 93       	push	r24
 7b4:	9f 93       	push	r25
 7b6:	af 93       	push	r26
 7b8:	bf 93       	push	r27
 7ba:	cf 93       	push	r28
 7bc:	df 93       	push	r29
 7be:	ef 93       	push	r30
 7c0:	ff 93       	push	r31
	uint16_t wLength;
	uint16_t desc_val;
	const uint8_t *desc_addr;
	uint8_t	desc_length;

        UENUM = 0;
 7c2:	10 92 e9 00 	sts	0x00E9, r1
	intbits = UEINTX;
 7c6:	80 91 e8 00 	lds	r24, 0x00E8
        if (intbits & (1<<RXSTPI)) {
 7ca:	83 ff       	sbrs	r24, 3
 7cc:	86 c1       	rjmp	.+780    	; 0xada <__vector_11+0x33e>
                bmRequestType = UEDATX;
 7ce:	40 91 f1 00 	lds	r20, 0x00F1
                bRequest = UEDATX;
 7d2:	30 91 f1 00 	lds	r19, 0x00F1
                wValue = UEDATX;
 7d6:	80 91 f1 00 	lds	r24, 0x00F1
 7da:	a8 2f       	mov	r26, r24
 7dc:	b0 e0       	ldi	r27, 0x00	; 0
                wValue |= (UEDATX << 8);
 7de:	20 91 f1 00 	lds	r18, 0x00F1
 7e2:	92 2f       	mov	r25, r18
 7e4:	80 e0       	ldi	r24, 0x00	; 0
 7e6:	a8 2b       	or	r26, r24
 7e8:	b9 2b       	or	r27, r25
                wIndex = UEDATX;
 7ea:	80 91 f1 00 	lds	r24, 0x00F1
 7ee:	68 2f       	mov	r22, r24
 7f0:	70 e0       	ldi	r23, 0x00	; 0
                wIndex |= (UEDATX << 8);
 7f2:	20 91 f1 00 	lds	r18, 0x00F1
 7f6:	92 2f       	mov	r25, r18
 7f8:	80 e0       	ldi	r24, 0x00	; 0
 7fa:	68 2b       	or	r22, r24
 7fc:	79 2b       	or	r23, r25
                wLength = UEDATX;
 7fe:	80 91 f1 00 	lds	r24, 0x00F1
 802:	c8 2f       	mov	r28, r24
 804:	d0 e0       	ldi	r29, 0x00	; 0
                wLength |= (UEDATX << 8);
 806:	20 91 f1 00 	lds	r18, 0x00F1
 80a:	92 2f       	mov	r25, r18
 80c:	80 e0       	ldi	r24, 0x00	; 0
 80e:	c8 2b       	or	r28, r24
 810:	d9 2b       	or	r29, r25
                UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 812:	82 ef       	ldi	r24, 0xF2	; 242
 814:	80 93 e8 00 	sts	0x00E8, r24
                if (bRequest == GET_DESCRIPTOR) {
 818:	36 30       	cpi	r19, 0x06	; 6
 81a:	09 f0       	breq	.+2      	; 0x81e <__vector_11+0x82>
 81c:	56 c0       	rjmp	.+172    	; 0x8ca <__vector_11+0x12e>
 81e:	27 ed       	ldi	r18, 0xD7	; 215
 820:	30 e0       	ldi	r19, 0x00	; 0
 822:	a9 01       	movw	r20, r18
 824:	45 50       	subi	r20, 0x05	; 5
 826:	50 40       	sbci	r21, 0x00	; 0
			list = (const uint8_t *)descriptor_list;
			for (i=0; ; i++) {
				if (i >= NUM_DESC_LIST) {
					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
					return;
 828:	f9 01       	movw	r30, r18
 82a:	37 97       	sbiw	r30, 0x07	; 7
				}
				desc_val = pgm_read_word(list);
 82c:	85 91       	lpm	r24, Z+
 82e:	94 91       	lpm	r25, Z+
				if (desc_val != wValue) {
 830:	8a 17       	cp	r24, r26
 832:	9b 07       	cpc	r25, r27
 834:	e1 f4       	brne	.+56     	; 0x86e <__vector_11+0xd2>
					list += sizeof(struct descriptor_list_struct);
					continue;
				}
				list += 2;
				desc_val = pgm_read_word(list);
 836:	fa 01       	movw	r30, r20
 838:	85 91       	lpm	r24, Z+
 83a:	94 91       	lpm	r25, Z+
				if (desc_val != wIndex) {
 83c:	86 17       	cp	r24, r22
 83e:	97 07       	cpc	r25, r23
 840:	b1 f4       	brne	.+44     	; 0x86e <__vector_11+0xd2>
					list += sizeof(struct descriptor_list_struct)-2;
					continue;
				}
				list += 2;
 842:	9a 01       	movw	r18, r20
 844:	2e 5f       	subi	r18, 0xFE	; 254
 846:	3f 4f       	sbci	r19, 0xFF	; 255
				desc_addr = (const uint8_t *)pgm_read_word(list);
 848:	f9 01       	movw	r30, r18
 84a:	65 91       	lpm	r22, Z+
 84c:	74 91       	lpm	r23, Z+
				list += 2;
				desc_length = pgm_read_byte(list);
 84e:	2e 5f       	subi	r18, 0xFE	; 254
 850:	3f 4f       	sbci	r19, 0xFF	; 255
 852:	f9 01       	movw	r30, r18
 854:	24 91       	lpm	r18, Z+
				break;
			}
			len = (wLength < 256) ? wLength : 255;
 856:	ce 01       	movw	r24, r28
 858:	cf 3f       	cpi	r28, 0xFF	; 255
 85a:	d1 05       	cpc	r29, r1
 85c:	19 f0       	breq	.+6      	; 0x864 <__vector_11+0xc8>
 85e:	10 f0       	brcs	.+4      	; 0x864 <__vector_11+0xc8>
 860:	8f ef       	ldi	r24, 0xFF	; 255
 862:	90 e0       	ldi	r25, 0x00	; 0
 864:	42 2f       	mov	r20, r18
 866:	82 17       	cp	r24, r18
 868:	58 f4       	brcc	.+22     	; 0x880 <__vector_11+0xe4>
 86a:	48 2f       	mov	r20, r24
 86c:	09 c0       	rjmp	.+18     	; 0x880 <__vector_11+0xe4>
 86e:	29 5f       	subi	r18, 0xF9	; 249
 870:	3f 4f       	sbci	r19, 0xFF	; 255
 872:	49 5f       	subi	r20, 0xF9	; 249
 874:	5f 4f       	sbci	r21, 0xFF	; 255
                wLength |= (UEDATX << 8);
                UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
                if (bRequest == GET_DESCRIPTOR) {
			list = (const uint8_t *)descriptor_list;
			for (i=0; ; i++) {
				if (i >= NUM_DESC_LIST) {
 876:	f1 e0       	ldi	r31, 0x01	; 1
 878:	26 31       	cpi	r18, 0x16	; 22
 87a:	3f 07       	cpc	r19, r31
 87c:	a9 f6       	brne	.-86     	; 0x828 <__vector_11+0x8c>
 87e:	2d c1       	rjmp	.+602    	; 0xada <__vector_11+0x33e>
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
 880:	5e ef       	ldi	r21, 0xFE	; 254
			len = (wLength < 256) ? wLength : 255;
			if (len > desc_length) len = desc_length;
			do {
				// wait for host ready for IN packet
				do {
					i = UEINTX;
 882:	80 91 e8 00 	lds	r24, 0x00E8
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 886:	28 2f       	mov	r18, r24
 888:	30 e0       	ldi	r19, 0x00	; 0
 88a:	c9 01       	movw	r24, r18
 88c:	85 70       	andi	r24, 0x05	; 5
 88e:	90 70       	andi	r25, 0x00	; 0
 890:	89 2b       	or	r24, r25
 892:	b9 f3       	breq	.-18     	; 0x882 <__vector_11+0xe6>
				if (i & (1<<RXOUTI)) return;	// abort
 894:	22 fd       	sbrc	r18, 2
 896:	24 c1       	rjmp	.+584    	; 0xae0 <__vector_11+0x344>
				// send IN packet
				n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 898:	34 2f       	mov	r19, r20
 89a:	41 32       	cpi	r20, 0x21	; 33
 89c:	08 f0       	brcs	.+2      	; 0x8a0 <__vector_11+0x104>
 89e:	30 e2       	ldi	r19, 0x20	; 32
 8a0:	23 2f       	mov	r18, r19
 8a2:	cb 01       	movw	r24, r22
 8a4:	06 c0       	rjmp	.+12     	; 0x8b2 <__vector_11+0x116>
				for (i = n; i; i--) {
 8a6:	fc 01       	movw	r30, r24
					UEDATX = pgm_read_byte(desc_addr++);
 8a8:	01 96       	adiw	r24, 0x01	; 1
 8aa:	e4 91       	lpm	r30, Z+
 8ac:	e0 93 f1 00 	sts	0x00F1, r30
					i = UEINTX;
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
				if (i & (1<<RXOUTI)) return;	// abort
				// send IN packet
				n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
				for (i = n; i; i--) {
 8b0:	21 50       	subi	r18, 0x01	; 1
 8b2:	22 23       	and	r18, r18
 8b4:	c1 f7       	brne	.-16     	; 0x8a6 <__vector_11+0x10a>
 8b6:	63 0f       	add	r22, r19
 8b8:	71 1d       	adc	r23, r1
					UEDATX = pgm_read_byte(desc_addr++);
				}
				len -= n;
 8ba:	43 1b       	sub	r20, r19
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
 8bc:	50 93 e8 00 	sts	0x00E8, r21
				for (i = n; i; i--) {
					UEDATX = pgm_read_byte(desc_addr++);
				}
				len -= n;
				usb_send_in();
			} while (len || n == ENDPOINT0_SIZE);
 8c0:	44 23       	and	r20, r20
 8c2:	f9 f6       	brne	.-66     	; 0x882 <__vector_11+0xe6>
 8c4:	30 32       	cpi	r19, 0x20	; 32
 8c6:	e9 f2       	breq	.-70     	; 0x882 <__vector_11+0xe6>
 8c8:	0b c1       	rjmp	.+534    	; 0xae0 <__vector_11+0x344>
			return;
                }
		if (bRequest == SET_ADDRESS) {
 8ca:	35 30       	cpi	r19, 0x05	; 5
 8cc:	61 f4       	brne	.+24     	; 0x8e6 <__vector_11+0x14a>
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
 8ce:	8e ef       	ldi	r24, 0xFE	; 254
 8d0:	80 93 e8 00 	sts	0x00E8, r24


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void)
{
	while (!(UEINTX & (1<<TXINI))) ;
 8d4:	80 91 e8 00 	lds	r24, 0x00E8
 8d8:	80 ff       	sbrs	r24, 0
 8da:	fc cf       	rjmp	.-8      	; 0x8d4 <__vector_11+0x138>
			return;
                }
		if (bRequest == SET_ADDRESS) {
			usb_send_in();
			usb_wait_in_ready();
			UDADDR = wValue | (1<<ADDEN);
 8dc:	8a 2f       	mov	r24, r26
 8de:	80 68       	ori	r24, 0x80	; 128
 8e0:	80 93 e3 00 	sts	0x00E3, r24
 8e4:	fd c0       	rjmp	.+506    	; 0xae0 <__vector_11+0x344>
			return;
		}
		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
 8e6:	39 30       	cpi	r19, 0x09	; 9
 8e8:	31 f5       	brne	.+76     	; 0x936 <__vector_11+0x19a>
 8ea:	44 23       	and	r20, r20
 8ec:	09 f0       	breq	.+2      	; 0x8f0 <__vector_11+0x154>
 8ee:	70 c0       	rjmp	.+224    	; 0x9d0 <__vector_11+0x234>
			usb_configuration = wValue;
 8f0:	a0 93 a6 01 	sts	0x01A6, r26
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
 8f4:	8e ef       	ldi	r24, 0xFE	; 254
 8f6:	80 93 e8 00 	sts	0x00E8, r24
 8fa:	8f e0       	ldi	r24, 0x0F	; 15
 8fc:	91 e0       	ldi	r25, 0x01	; 1
 8fe:	21 e0       	ldi	r18, 0x01	; 1
		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
			usb_configuration = wValue;
			usb_send_in();
			cfg = endpoint_config_table;
			for (i=1; i<5; i++) {
				UENUM = i;
 900:	20 93 e9 00 	sts	0x00E9, r18
				en = pgm_read_byte(cfg++);
 904:	fc 01       	movw	r30, r24
 906:	01 96       	adiw	r24, 0x01	; 1
 908:	e4 91       	lpm	r30, Z+
				UECONX = en;
 90a:	e0 93 eb 00 	sts	0x00EB, r30
				if (en) {
 90e:	ee 23       	and	r30, r30
 910:	69 f0       	breq	.+26     	; 0x92c <__vector_11+0x190>
					UECFG0X = pgm_read_byte(cfg++);
 912:	ac 01       	movw	r20, r24
 914:	4f 5f       	subi	r20, 0xFF	; 255
 916:	5f 4f       	sbci	r21, 0xFF	; 255
 918:	fc 01       	movw	r30, r24
 91a:	84 91       	lpm	r24, Z+
 91c:	80 93 ec 00 	sts	0x00EC, r24
					UECFG1X = pgm_read_byte(cfg++);
 920:	ca 01       	movw	r24, r20
 922:	01 96       	adiw	r24, 0x01	; 1
 924:	fa 01       	movw	r30, r20
 926:	34 91       	lpm	r19, Z+
 928:	30 93 ed 00 	sts	0x00ED, r19
		}
		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
			usb_configuration = wValue;
			usb_send_in();
			cfg = endpoint_config_table;
			for (i=1; i<5; i++) {
 92c:	2f 5f       	subi	r18, 0xFF	; 255
 92e:	25 30       	cpi	r18, 0x05	; 5
 930:	39 f7       	brne	.-50     	; 0x900 <__vector_11+0x164>
				if (en) {
					UECFG0X = pgm_read_byte(cfg++);
					UECFG1X = pgm_read_byte(cfg++);
				}
			}
        		UERST = 0x1E;
 932:	8e e1       	ldi	r24, 0x1E	; 30
 934:	48 c0       	rjmp	.+144    	; 0x9c6 <__vector_11+0x22a>
        		UERST = 0;
			return;
		}
		if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {
 936:	38 30       	cpi	r19, 0x08	; 8
 938:	51 f4       	brne	.+20     	; 0x94e <__vector_11+0x1b2>
 93a:	40 38       	cpi	r20, 0x80	; 128
 93c:	09 f0       	breq	.+2      	; 0x940 <__vector_11+0x1a4>
 93e:	48 c0       	rjmp	.+144    	; 0x9d0 <__vector_11+0x234>


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void)
{
	while (!(UEINTX & (1<<TXINI))) ;
 940:	80 91 e8 00 	lds	r24, 0x00E8
 944:	80 ff       	sbrs	r24, 0
 946:	fc cf       	rjmp	.-8      	; 0x940 <__vector_11+0x1a4>
        		UERST = 0;
			return;
		}
		if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {
			usb_wait_in_ready();
			UEDATX = usb_configuration;
 948:	80 91 a6 01 	lds	r24, 0x01A6
 94c:	7c c0       	rjmp	.+248    	; 0xa46 <__vector_11+0x2aa>
			usb_send_in();
			return;
		}

		if (bRequest == GET_STATUS) {
 94e:	33 23       	and	r19, r19
 950:	d1 f4       	brne	.+52     	; 0x986 <__vector_11+0x1ea>


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void)
{
	while (!(UEINTX & (1<<TXINI))) ;
 952:	80 91 e8 00 	lds	r24, 0x00E8
 956:	80 ff       	sbrs	r24, 0
 958:	fc cf       	rjmp	.-8      	; 0x952 <__vector_11+0x1b6>

		if (bRequest == GET_STATUS) {
			usb_wait_in_ready();
			i = 0;
			#ifdef SUPPORT_ENDPOINT_HALT
			if (bmRequestType == 0x82) {
 95a:	42 38       	cpi	r20, 0x82	; 130
 95c:	11 f0       	breq	.+4      	; 0x962 <__vector_11+0x1c6>
 95e:	80 e0       	ldi	r24, 0x00	; 0
 960:	0d c0       	rjmp	.+26     	; 0x97c <__vector_11+0x1e0>
				UENUM = wIndex;
 962:	60 93 e9 00 	sts	0x00E9, r22
				if (UECONX & (1<<STALLRQ)) i = 1;
 966:	80 91 eb 00 	lds	r24, 0x00EB
 96a:	90 e0       	ldi	r25, 0x00	; 0
 96c:	25 e0       	ldi	r18, 0x05	; 5
 96e:	96 95       	lsr	r25
 970:	87 95       	ror	r24
 972:	2a 95       	dec	r18
 974:	e1 f7       	brne	.-8      	; 0x96e <__vector_11+0x1d2>
 976:	81 70       	andi	r24, 0x01	; 1
				UENUM = 0;
 978:	10 92 e9 00 	sts	0x00E9, r1
			}
			#endif
			UEDATX = i;
 97c:	80 93 f1 00 	sts	0x00F1, r24
			UEDATX = 0;
 980:	10 92 f1 00 	sts	0x00F1, r1
 984:	7f c0       	rjmp	.+254    	; 0xa84 <__vector_11+0x2e8>
			usb_send_in();
			return;
		}
		#ifdef SUPPORT_ENDPOINT_HALT
		if ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)
 986:	31 30       	cpi	r19, 0x01	; 1
 988:	11 f0       	breq	.+4      	; 0x98e <__vector_11+0x1f2>
 98a:	33 30       	cpi	r19, 0x03	; 3
 98c:	09 f5       	brne	.+66     	; 0x9d0 <__vector_11+0x234>
 98e:	42 30       	cpi	r20, 0x02	; 2
 990:	f9 f4       	brne	.+62     	; 0x9d0 <__vector_11+0x234>
 992:	10 97       	sbiw	r26, 0x00	; 0
 994:	e9 f4       	brne	.+58     	; 0x9d0 <__vector_11+0x234>
		  && bmRequestType == 0x02 && wValue == 0) {
			i = wIndex & 0x7F;
 996:	26 2f       	mov	r18, r22
 998:	2f 77       	andi	r18, 0x7F	; 127
			if (i >= 1 && i <= MAX_ENDPOINT) {
 99a:	82 2f       	mov	r24, r18
 99c:	81 50       	subi	r24, 0x01	; 1
 99e:	84 30       	cpi	r24, 0x04	; 4
 9a0:	b8 f4       	brcc	.+46     	; 0x9d0 <__vector_11+0x234>
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
 9a2:	8e ef       	ldi	r24, 0xFE	; 254
 9a4:	80 93 e8 00 	sts	0x00E8, r24
		if ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)
		  && bmRequestType == 0x02 && wValue == 0) {
			i = wIndex & 0x7F;
			if (i >= 1 && i <= MAX_ENDPOINT) {
				usb_send_in();
				UENUM = i;
 9a8:	20 93 e9 00 	sts	0x00E9, r18
				if (bRequest == SET_FEATURE) {
 9ac:	33 30       	cpi	r19, 0x03	; 3
 9ae:	09 f4       	brne	.+2      	; 0x9b2 <__vector_11+0x216>
 9b0:	94 c0       	rjmp	.+296    	; 0xada <__vector_11+0x33e>
					UECONX = (1<<STALLRQ)|(1<<EPEN);
				} else {
					UECONX = (1<<STALLRQC)|(1<<RSTDT)|(1<<EPEN);
 9b2:	89 e1       	ldi	r24, 0x19	; 25
 9b4:	80 93 eb 00 	sts	0x00EB, r24
					UERST = (1 << i);
 9b8:	81 e0       	ldi	r24, 0x01	; 1
 9ba:	90 e0       	ldi	r25, 0x00	; 0
 9bc:	02 c0       	rjmp	.+4      	; 0x9c2 <__vector_11+0x226>
 9be:	88 0f       	add	r24, r24
 9c0:	99 1f       	adc	r25, r25
 9c2:	2a 95       	dec	r18
 9c4:	e2 f7       	brpl	.-8      	; 0x9be <__vector_11+0x222>
 9c6:	80 93 ea 00 	sts	0x00EA, r24
					UERST = 0;
 9ca:	10 92 ea 00 	sts	0x00EA, r1
 9ce:	88 c0       	rjmp	.+272    	; 0xae0 <__vector_11+0x344>
				}
				return;
			}
		}
		#endif
		if (wIndex == KEYBOARD_INTERFACE) {
 9d0:	61 15       	cp	r22, r1
 9d2:	71 05       	cpc	r23, r1
 9d4:	09 f0       	breq	.+2      	; 0x9d8 <__vector_11+0x23c>
 9d6:	5a c0       	rjmp	.+180    	; 0xa8c <__vector_11+0x2f0>
			if (bmRequestType == 0xA1) {
 9d8:	41 3a       	cpi	r20, 0xA1	; 161
 9da:	c1 f5       	brne	.+112    	; 0xa4c <__vector_11+0x2b0>
				if (bRequest == HID_GET_REPORT) {
 9dc:	31 30       	cpi	r19, 0x01	; 1
 9de:	09 f5       	brne	.+66     	; 0xa22 <__vector_11+0x286>


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void)
{
	while (!(UEINTX & (1<<TXINI))) ;
 9e0:	80 91 e8 00 	lds	r24, 0x00E8
 9e4:	80 ff       	sbrs	r24, 0
 9e6:	fc cf       	rjmp	.-8      	; 0x9e0 <__vector_11+0x244>
		#endif
		if (wIndex == KEYBOARD_INTERFACE) {
			if (bmRequestType == 0xA1) {
				if (bRequest == HID_GET_REPORT) {
					usb_wait_in_ready();
					UEDATX = keyboard_modifier_keys;
 9e8:	80 91 9e 01 	lds	r24, 0x019E
 9ec:	80 93 f1 00 	sts	0x00F1, r24
					UEDATX = 0;
 9f0:	10 92 f1 00 	sts	0x00F1, r1
					for (i=0; i<6; i++) {
						UEDATX = keyboard_keys[i];
 9f4:	80 91 9f 01 	lds	r24, 0x019F
 9f8:	80 93 f1 00 	sts	0x00F1, r24
 9fc:	80 91 a0 01 	lds	r24, 0x01A0
 a00:	80 93 f1 00 	sts	0x00F1, r24
 a04:	80 91 a1 01 	lds	r24, 0x01A1
 a08:	80 93 f1 00 	sts	0x00F1, r24
 a0c:	80 91 a2 01 	lds	r24, 0x01A2
 a10:	80 93 f1 00 	sts	0x00F1, r24
 a14:	80 91 a3 01 	lds	r24, 0x01A3
 a18:	80 93 f1 00 	sts	0x00F1, r24
 a1c:	80 91 a4 01 	lds	r24, 0x01A4
 a20:	12 c0       	rjmp	.+36     	; 0xa46 <__vector_11+0x2aa>
					}
					usb_send_in();
					return;
				}
				if (bRequest == HID_GET_IDLE) {
 a22:	32 30       	cpi	r19, 0x02	; 2
 a24:	39 f4       	brne	.+14     	; 0xa34 <__vector_11+0x298>


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void)
{
	while (!(UEINTX & (1<<TXINI))) ;
 a26:	80 91 e8 00 	lds	r24, 0x00E8
 a2a:	80 ff       	sbrs	r24, 0
 a2c:	fc cf       	rjmp	.-8      	; 0xa26 <__vector_11+0x28a>
					usb_send_in();
					return;
				}
				if (bRequest == HID_GET_IDLE) {
					usb_wait_in_ready();
					UEDATX = keyboard_idle_config;
 a2e:	80 91 99 01 	lds	r24, 0x0199
 a32:	09 c0       	rjmp	.+18     	; 0xa46 <__vector_11+0x2aa>
					usb_send_in();
					return;
				}
				if (bRequest == HID_GET_PROTOCOL) {
 a34:	33 30       	cpi	r19, 0x03	; 3
 a36:	09 f0       	breq	.+2      	; 0xa3a <__vector_11+0x29e>
 a38:	50 c0       	rjmp	.+160    	; 0xada <__vector_11+0x33e>


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void)
{
	while (!(UEINTX & (1<<TXINI))) ;
 a3a:	80 91 e8 00 	lds	r24, 0x00E8
 a3e:	80 ff       	sbrs	r24, 0
 a40:	fc cf       	rjmp	.-8      	; 0xa3a <__vector_11+0x29e>
					usb_send_in();
					return;
				}
				if (bRequest == HID_GET_PROTOCOL) {
					usb_wait_in_ready();
					UEDATX = keyboard_protocol;
 a42:	80 91 9a 01 	lds	r24, 0x019A
 a46:	80 93 f1 00 	sts	0x00F1, r24
 a4a:	1c c0       	rjmp	.+56     	; 0xa84 <__vector_11+0x2e8>
					usb_send_in();
					return;
				}
			}
			if (bmRequestType == 0x21) {
 a4c:	41 32       	cpi	r20, 0x21	; 33
 a4e:	09 f0       	breq	.+2      	; 0xa52 <__vector_11+0x2b6>
 a50:	44 c0       	rjmp	.+136    	; 0xada <__vector_11+0x33e>
				if (bRequest == HID_SET_REPORT) {
 a52:	39 30       	cpi	r19, 0x09	; 9
 a54:	61 f4       	brne	.+24     	; 0xa6e <__vector_11+0x2d2>
{
	UEINTX = ~(1<<TXINI);
}
static inline void usb_wait_receive_out(void)
{
	while (!(UEINTX & (1<<RXOUTI))) ;
 a56:	80 91 e8 00 	lds	r24, 0x00E8
 a5a:	82 ff       	sbrs	r24, 2
 a5c:	fc cf       	rjmp	.-8      	; 0xa56 <__vector_11+0x2ba>
				}
			}
			if (bmRequestType == 0x21) {
				if (bRequest == HID_SET_REPORT) {
					usb_wait_receive_out();
					keyboard_leds = UEDATX;
 a5e:	80 91 f1 00 	lds	r24, 0x00F1
 a62:	80 93 a5 01 	sts	0x01A5, r24
{
	while (!(UEINTX & (1<<RXOUTI))) ;
}
static inline void usb_ack_out(void)
{
	UEINTX = ~(1<<RXOUTI);
 a66:	8b ef       	ldi	r24, 0xFB	; 251
 a68:	80 93 e8 00 	sts	0x00E8, r24
 a6c:	0b c0       	rjmp	.+22     	; 0xa84 <__vector_11+0x2e8>
					keyboard_leds = UEDATX;
					usb_ack_out();
					usb_send_in();
					return;
				}
				if (bRequest == HID_SET_IDLE) {
 a6e:	3a 30       	cpi	r19, 0x0A	; 10
 a70:	29 f4       	brne	.+10     	; 0xa7c <__vector_11+0x2e0>
					keyboard_idle_config = (wValue >> 8);
 a72:	b0 93 99 01 	sts	0x0199, r27
					keyboard_idle_count = 0;
 a76:	10 92 a7 01 	sts	0x01A7, r1
 a7a:	04 c0       	rjmp	.+8      	; 0xa84 <__vector_11+0x2e8>
					//usb_wait_in_ready();
					usb_send_in();
					return;
				}
				if (bRequest == HID_SET_PROTOCOL) {
 a7c:	3b 30       	cpi	r19, 0x0B	; 11
 a7e:	69 f5       	brne	.+90     	; 0xada <__vector_11+0x33e>
					keyboard_protocol = wValue;
 a80:	a0 93 9a 01 	sts	0x019A, r26
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
 a84:	8e ef       	ldi	r24, 0xFE	; 254
 a86:	80 93 e8 00 	sts	0x00E8, r24
 a8a:	2a c0       	rjmp	.+84     	; 0xae0 <__vector_11+0x344>
					usb_send_in();
					return;
				}
			}
		}
		if (wIndex == DEBUG_INTERFACE) {
 a8c:	61 30       	cpi	r22, 0x01	; 1
 a8e:	71 05       	cpc	r23, r1
 a90:	21 f5       	brne	.+72     	; 0xada <__vector_11+0x33e>
			if (bRequest == HID_GET_REPORT && bmRequestType == 0xA1) {
 a92:	31 30       	cpi	r19, 0x01	; 1
 a94:	11 f5       	brne	.+68     	; 0xada <__vector_11+0x33e>
 a96:	41 3a       	cpi	r20, 0xA1	; 161
 a98:	01 f5       	brne	.+64     	; 0xada <__vector_11+0x33e>
				len = wLength;
 a9a:	4c 2f       	mov	r20, r28
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
 a9c:	5e ef       	ldi	r21, 0xFE	; 254
			if (bRequest == HID_GET_REPORT && bmRequestType == 0xA1) {
				len = wLength;
				do {
					// wait for host ready for IN packet
					do {
						i = UEINTX;
 a9e:	80 91 e8 00 	lds	r24, 0x00E8
					} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 aa2:	28 2f       	mov	r18, r24
 aa4:	30 e0       	ldi	r19, 0x00	; 0
 aa6:	c9 01       	movw	r24, r18
 aa8:	85 70       	andi	r24, 0x05	; 5
 aaa:	90 70       	andi	r25, 0x00	; 0
 aac:	89 2b       	or	r24, r25
 aae:	b9 f3       	breq	.-18     	; 0xa9e <__vector_11+0x302>
					if (i & (1<<RXOUTI)) return;	// abort
 ab0:	22 fd       	sbrc	r18, 2
 ab2:	16 c0       	rjmp	.+44     	; 0xae0 <__vector_11+0x344>
					// send IN packet
					n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 ab4:	94 2f       	mov	r25, r20
 ab6:	41 32       	cpi	r20, 0x21	; 33
 ab8:	08 f0       	brcs	.+2      	; 0xabc <__vector_11+0x320>
 aba:	90 e2       	ldi	r25, 0x20	; 32
 abc:	89 2f       	mov	r24, r25
 abe:	03 c0       	rjmp	.+6      	; 0xac6 <__vector_11+0x32a>
					for (i = n; i; i--) {
						UEDATX = 0;
 ac0:	10 92 f1 00 	sts	0x00F1, r1
						i = UEINTX;
					} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
					if (i & (1<<RXOUTI)) return;	// abort
					// send IN packet
					n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
					for (i = n; i; i--) {
 ac4:	81 50       	subi	r24, 0x01	; 1
 ac6:	88 23       	and	r24, r24
 ac8:	d9 f7       	brne	.-10     	; 0xac0 <__vector_11+0x324>
						UEDATX = 0;
					}
					len -= n;
 aca:	49 1b       	sub	r20, r25
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
 acc:	50 93 e8 00 	sts	0x00E8, r21
					for (i = n; i; i--) {
						UEDATX = 0;
					}
					len -= n;
					usb_send_in();
				} while (len || n == ENDPOINT0_SIZE);
 ad0:	44 23       	and	r20, r20
 ad2:	29 f7       	brne	.-54     	; 0xa9e <__vector_11+0x302>
 ad4:	90 32       	cpi	r25, 0x20	; 32
 ad6:	19 f3       	breq	.-58     	; 0xa9e <__vector_11+0x302>
 ad8:	03 c0       	rjmp	.+6      	; 0xae0 <__vector_11+0x344>
				return;
			}
		}
	}
	UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
 ada:	81 e2       	ldi	r24, 0x21	; 33
 adc:	80 93 eb 00 	sts	0x00EB, r24
}
 ae0:	ff 91       	pop	r31
 ae2:	ef 91       	pop	r30
 ae4:	df 91       	pop	r29
 ae6:	cf 91       	pop	r28
 ae8:	bf 91       	pop	r27
 aea:	af 91       	pop	r26
 aec:	9f 91       	pop	r25
 aee:	8f 91       	pop	r24
 af0:	7f 91       	pop	r23
 af2:	6f 91       	pop	r22
 af4:	5f 91       	pop	r21
 af6:	4f 91       	pop	r20
 af8:	3f 91       	pop	r19
 afa:	2f 91       	pop	r18
 afc:	0f 90       	pop	r0
 afe:	0f be       	out	0x3f, r0	; 63
 b00:	0f 90       	pop	r0
 b02:	1f 90       	pop	r1
 b04:	18 95       	reti

00000b06 <print_P>:
#include <avr/pgmspace.h>

#include "print.h"

void print_P(const char *s)
{
 b06:	1f 93       	push	r17
 b08:	cf 93       	push	r28
 b0a:	df 93       	push	r29
 b0c:	ec 01       	movw	r28, r24
 b0e:	fe 01       	movw	r30, r28
	char c;

	while (1) {
		c = pgm_read_byte(s++);
 b10:	21 96       	adiw	r28, 0x01	; 1
 b12:	14 91       	lpm	r17, Z+
		if (!c) break;
 b14:	11 23       	and	r17, r17
 b16:	39 f0       	breq	.+14     	; 0xb26 <print_P+0x20>
		if (c == '\n') usb_debug_putchar('\r');
 b18:	1a 30       	cpi	r17, 0x0A	; 10
 b1a:	11 f4       	brne	.+4      	; 0xb20 <print_P+0x1a>
 b1c:	8d e0       	ldi	r24, 0x0D	; 13
 b1e:	76 dd       	rcall	.-1300   	; 0x60c <usb_debug_putchar>
		usb_debug_putchar(c);
 b20:	81 2f       	mov	r24, r17
 b22:	74 dd       	rcall	.-1304   	; 0x60c <usb_debug_putchar>
 b24:	f4 cf       	rjmp	.-24     	; 0xb0e <print_P+0x8>
	}
}
 b26:	df 91       	pop	r29
 b28:	cf 91       	pop	r28
 b2a:	1f 91       	pop	r17
 b2c:	08 95       	ret

00000b2e <_exit>:
 b2e:	f8 94       	cli

00000b30 <__stop_program>:
 b30:	ff cf       	rjmp	.-2      	; 0xb30 <__stop_program>
